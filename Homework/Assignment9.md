# Tyerra Smith  
## October 21, 2017  

1. I think that human error and changing requirements are equally important in reference to 
"software development is considerably different in practice". I think this because the requirements 
are changing just as much as the humans are making errors within production. Though people that are 
involved in this line of work should be very careful and pay special attention to detail, they are 
still human which means they are prone to make mistakes. With this new era of technological innovations,
requirements constantly change in order to adapt to the technology that is used to complete the process.  

2. I think that when the book says, "the waterfall is iterative but not incremental", it means that though 
you go to different stages within the model, you do not repeat those stages. It's pretty much a one and done 
type of situation where once you move on to the next stage, you don't go back only forward.  

3. When I think about the stepwise refinement development model, I think of recursion. When I think about 
recursion, I think about the Fibonnacci sequence so I would say that when programming a a recursive problem 
as such, I used to stepwise refinement model. I coded a smaller portion of the problem first. Once getting 
the code to produuce the correct output, I extended the code to produce the correct output for larger inputs. 
Once the basis steps were working correctly the recursive step was added and that solved the problem. I think the 
stepwise refinement model is helpful on large math problems and recursive proramming problems.  

4. The requirements workflow should be included in all iterations because everytime your find that there is another 
feature that should be incorporated or is needed in order to give the product the most functionality, the SRS should be 
updated to reflect these changes. These newly found needs are usually discovered in the iterations that follow the 
requirements workflow. The Test workflow should not bein until iteration two at the earliest because after the first 
iteration, there is usually nothing to test. Testing is only applicable after design and implementation has began.  

5. If I had to explain the iterative and incremental model to a young programmer, I would tell them that it is like 
following a sequence of steps, but also following another sequence of steps within each step. The goal is to get as 
far as you can within each step, adding functionality as you move forward. Once each step has been completed, they are 
to be compiled into one final product and examined for errors and bugs.  

6. I totally agree with the statement that “[a] critical point regarding the waterfall model is that no phase is 
complete until the documentation for that phase has been completed”. I agree with this statement because most projects 
are developed over a period of time so your train of thought at one point may be different when you revisit it later. To 
keep from starting over with each new train of thought, documentation could help you remember and understand what you were 
initially trying to do. This is just one of the many helps that documentation lends. To conform to this dictate, I would make 
documentation a different workflow that is incorporated through the entire process just as testing is. Test, then document.  

7. Though there are other models that would probably save me time and hassle, I would feel most comfortable with the Code-and-
Fix Life-Cycle model. I would feel most comfortable with this model mainly because this is the way that I like to go about 
completing projects. Why I like to do things this way is not clear to me. I just do. I know that during the process I am liable 
to change things a million and one times but I usually learn new things during the cousre of completing projects this way. I code 
until I get stuck. Then, i utilize my resources to help ferment more thought and get me past the coding block.  

8. When reading part two of the Recursive Functions of Symbolic Expressions and Their Computation by Machine paper, I was immediately 
taken back to the pain and hardship that I experienced during my Intro to Discrete Mathematics class. During this class , we had to prove 
the theories and mathematical expressions that were presented in this paper. Though some of the expressions are similiar to those that I 
have seen in previous Math classes such as Pre-Calculus and Calculus, proving the expressions are much harder than plugging numbers into 
the exxpressions to solve for given values. There is valuable information that could be applied in the Computer Science field of study but 
though I love Math, I will try my best to steer clear of these general and 'discrete' mathematical expressions.
