# Tyerra Smith  
## October 28, 2017  

1. In building a software product, the book identifies two kinds of planning that must occur:  
	a) the planning that proceeds throughout the project (i.e. how a particular function will be implemented 
		and whether one data structure should be used over another to be most effective/efficient) and  
	b) the intense planning that must be carried out once the specifications are complete (i.e. what language 
		will be used for implementation and who will work on what portion of the project).  
	
2. Figure 9.1 shows how difficult it is to present duration and cost estimates before the specifications 
haave been drawn up. This is problematic because estimates that are presented before the the specifications 
and design phases are premature. This is becuase before these phases there are no specifics as to what is to 
be implemented and how. Without these specifics, any estimation is going to be far from the actual costs for 
for the project. 

3. The book identifies two different kinds of costs associated with building a software product:  
	a) internal cost: the cost to the developers (i.e. salaries of the development teams; the cost 
	of hardware and software) 
	b) external cost: the price that the client will pay (i.e.sals prices may be effected by developers 
	desparately needing work)  
	
4. Problems associated with the use if lines of code (LOC):  
 	a) The number of lines of code in the final product can be determined only when the product is 
	completely finished. (i.e. You can't use the number of lines of code that you used in a similiar project 
	to the project at hand. There is no way to accurately guess a LOC value for a given project.)  
	b) Not all the code implemented is delivered to the client. (i.e. I have included tests within the code 
	just to find the error or to mske sure that a certain line has been executed. These lines were later 
	omitted before turning in the project.)  
	c) It often is unclear exactly how to count lines of code. (i.e. It is not clear whether a loop is counted 
	as one or if each line is counted separately. It is also not clear whether comment are to be counted in LOC 
	either.)  
	d) Implementing the same product in two different languages results in versions with different numbers 
	of lines of code. (i.e. I have implemented the same project in Python and in Java and Python generally uses 
	the least LOC when comparing the two projects.)  

5. Function Point Metrics was developed by Allan Albrecht while he was employed at IBM in the 1970s. Function Points 
measure software size by quantifying the functionality provided to the user based solely on logical design and 
functional specifications. The Function Point Metric System is an alternative to using LOC. This system overcomes the 
problems that are usually encountered by LOC because it is independent of the language and tools that are used to 
implement a given project and they can be used for estimation in the early phases, such analysis and design. There are 
steps that are taken to estimate the function points but there does seem to be a widely accepted formula for it.  

6. Project initiation is very important. When looking to create a project, it is important to generate an estimate of the 
cost of the project so that you will have a general idea of the project's budget. It is also important to know who will be 
doing what to implement and bring the final product into existence. You should also get an idea of the resources that will be 
needed for the project and figure out how you will acquire those resources. Lastly, you should be sure that your develepment and 
implementation teams are properly trained and prepared to execute the project at hand.  

7. A practice that I would like to adopt in an effort to generate appropriate documentation for my project is to begin documentation 
just before I try to implement an idea or design. Basically, once I determine the way that I want to go about implementing a functionality 
of my project, I will write down the idea and steps that I plan to take before hand. I would also like to, once implemented, go back to the
beforehand documentation and adjust the documentation so that it reflects what I've actually implemented and how I went about implementing it. 
The purpose of this is to keep track of my thoughts and approaches to tat particular functionalityso that if I decide to take a break and come 
back to it, the documentation could serve as a guie for me to pick up where I left off.  

8. I think a user would conclude that you did not write a piece of software if you did not document the software because that is the most clear 
way to explain your code. I have experienced not documentaing and it it much harder to explain the code without documentation than with documentation 
whether you are the author of the code or not.  
